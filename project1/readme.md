## 多執行緒程式實作
### 原始程式碼 (User space code)


編譯時須加上 -lpthread 選項
```gcc main.c -lpthread -o main```

### 輸出
在當前目錄下輸入 ``./main`` 
會得到以下輸出 (執行緒間輸出的順序不固定)
```
thread: t1
The value of thread_i in t1: 1 (address: 0x7feaf7f2e6fc)
The address of char *str in t1       [stack]: 0x7feaf7f2ded8
The address of char *local_str in t1 [stack]: 0x7feaf7f2dea0
The value of char *heap_str in t1    [heap|shared_memory]: 0x7feaf0000b60
The address of global variable char *global_str: 0x5614002d6010

thread: t2
The value of thread_i in t2: 2 (address: 0x7feaf772d6fc)
The address of char *str in t2       [stack]: 0x7feaf772ced8
The address of char *local_str in t2 [stack]: 0x7feaf772cea0
The value of char *heap_str in t2    [heap|shared_memory]: 0x7feae8000b60
The address of global variable char *global_str: 0x5614002d6010

thread: main
The value of thread_i in main: 0 (address: 0x7feaf7f2f73c)
The address of char *str in main    [stack]: 0x7ffe1c69ac40
The value of char *heap_str in main [heap]: 0x56140121e500
The address of global variable char *global_str: 0x5614002d6010
```
* 可以發現全域變數 `__thread int thread_i` 在**不同執行緒裡都有一份 (位址不同，為不同的變數)**

符合 [Thread-Local Storage](https://web.mit.edu/rhel-doc/3/rhel-gcc-en-3/thread-local.html) 裡面對 thread-local variable 的說明

---
### Virtual memory layout
*(此 multi-thead program 的 virtual memory layout 還有待探討)*

根據 [Jason/cntofu.com, 深入 Linux 多線程編程](https://cntofu.com/book/46/linux_system/shen_rulinux_duo_xian_cheng_bian_cheng.md)，同一個 process 內的執行緒共享 global variables, heap 但每個執行緒都有自己的 stack，由此推論 `char *str` 應位於執行緒自身的 stack 中 (在函式中宣告，為 local variable)

結合上方程式輸出與下方 vmmap 的輸出，能夠發現 main() 中的 `char *str` 位於 [stack] 區段，而 `start_routine()` 中的 `char *str` 則位於 `/usr/lib/x86_64-linux-gnu/libgcc_s.so.1` 與 `/usr/lib/x86_64-linux-gnu/libc-2.31.so` 之間的可讀可寫區段，應可判斷此區段即為執行緒自身的 stack

#### Memory Space Mapping Generated by vmmap in GDB
```
gef➤  vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x005614002d2000 0x005614002d3000 0x00000000000000 r-- /home/shang/repo/Linux-OS-projects/project1/main
0x005614002d3000 0x005614002d4000 0x00000000001000 r-x /home/shang/repo/Linux-OS-projects/project1/main
0x005614002d4000 0x005614002d5000 0x00000000002000 r-- /home/shang/repo/Linux-OS-projects/project1/main
0x005614002d5000 0x005614002d6000 0x00000000002000 r-- /home/shang/repo/Linux-OS-projects/project1/main
0x005614002d6000 0x005614002d7000 0x00000000003000 rw- /home/shang/repo/Linux-OS-projects/project1/main
0x0056140121e000 0x0056140123f000 0x00000000000000 rw- [heap]

0x007feae8000000 0x007feae8021000 0x00000000000000 rw- **[heap for thread 2]**
0x007feae8021000 0x007feaec000000 0x00000000000000 --- 
0x007feaf0000000 0x007feaf0021000 0x00000000000000 rw- **[heap for thread 1]**
0x007feaf0021000 0x007feaf4000000 0x00000000000000 --- 
0x007feaf6f12000 0x007feaf6f15000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libgcc_s.so.1
0x007feaf6f15000 0x007feaf6f27000 0x00000000003000 r-x /usr/lib/x86_64-linux-gnu/libgcc_s.so.1
0x007feaf6f27000 0x007feaf6f2b000 0x00000000015000 r-- /usr/lib/x86_64-linux-gnu/libgcc_s.so.1
0x007feaf6f2b000 0x007feaf6f2c000 0x00000000018000 r-- /usr/lib/x86_64-linux-gnu/libgcc_s.so.1
0x007feaf6f2c000 0x007feaf6f2d000 0x00000000019000 rw- /usr/lib/x86_64-linux-gnu/libgcc_s.so.1
0x007feaf6f2d000 0x007feaf6f2e000 0x00000000000000 --- 
0x007feaf6f2e000 0x007feaf772e000 0x00000000000000 rw- **[stack for thread 2]**
0x007feaf772e000 0x007feaf772f000 0x00000000000000 --- 
0x007feaf772f000 0x007feaf7f32000 0x00000000000000 rw- **[stack for thread 1]**
0x007feaf7f32000 0x007feaf7f54000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so
0x007feaf7f54000 0x007feaf80cc000 0x00000000022000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so
0x007feaf80cc000 0x007feaf811a000 0x0000000019a000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so
0x007feaf811a000 0x007feaf811e000 0x000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so
0x007feaf811e000 0x007feaf8120000 0x000000001eb000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so
0x007feaf8120000 0x007feaf8124000 0x00000000000000 rw- 
0x007feaf8124000 0x007feaf812a000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so
0x007feaf812a000 0x007feaf813b000 0x00000000006000 r-x /usr/lib/x86_64-linux-gnu/libpthread-2.31.so
0x007feaf813b000 0x007feaf8141000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so
0x007feaf8141000 0x007feaf8142000 0x0000000001c000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so
0x007feaf8142000 0x007feaf8143000 0x0000000001d000 rw- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so
0x007feaf8143000 0x007feaf8149000 0x00000000000000 rw- 
0x007feaf815f000 0x007feaf8160000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so
0x007feaf8160000 0x007feaf8183000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.31.so
0x007feaf8183000 0x007feaf818b000 0x00000000024000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so
0x007feaf818c000 0x007feaf818d000 0x0000000002c000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so
0x007feaf818d000 0x007feaf818e000 0x0000000002d000 rw- /usr/lib/x86_64-linux-gnu/ld-2.31.so
0x007feaf818e000 0x007feaf818f000 0x00000000000000 rw- 
0x007ffe1c67b000 0x007ffe1c69c000 0x00000000000000 rw- [stack]
0x007ffe1c754000 0x007ffe1c758000 0x00000000000000 r-- [vvar]
0x007ffe1c758000 0x007ffe1c759000 0x00000000000000 r-x [vdso]
```
進一步確認可發現
* **兩個執行緒 t1, t2 的 `char *str` 位於不同的區段**，應為兩執行緒各自的 stack (上方標示之 [stack for thread[1|2]])
* 在執行緒的 `start_routine()` 中透過 `malloc()` 動態配置的由 `char *heap_str` 所指向的空間位於 [heap] 與 `/usr/lib/x86_64-linux-gnu/libgcc_s.so.1` 之間的**兩個不同的可讀可寫區段** (上方標示之 [heap for thread[1|2]])  
根據 [Jason/cntofu.com, 深入 Linux 多線程編程](https://cntofu.com/book/46/linux_system/shen_rulinux_duo_xian_cheng_bian_cheng.md)，該空間應是屬於 shared library, shared memory
> 問題一: 若同一 process 內的執行緒共享 [heap] 的話，則上述的狀況可能是 shared memory 導致的結果? 為了解決這個問題，得先解決另一問題: ***如何確認兩 virtual addresses 是否會被轉換為同一 physical address***  
也就是**如何確認一記憶體區段是否為 shared memory**
* 

### References:
> [Thread-Local Storage](https://web.mit.edu/rhel-doc/3/rhel-gcc-en-3/thread-local.html)  
> [G. T. Wang, C 語言 pthread 多執行緒平行化程式設計入門教學與範例](https://blog.gtwang.org/programming/pthread-multithreading-programming-in-c-tutorial/)  
> [Jason/cntofu.com, 深入 Linux 多線程編程](https://cntofu.com/book/46/linux_system/shen_rulinux_duo_xian_cheng_bian_cheng.md)  
> [Project 1 from course website](https://staff.csie.ncu.edu.tw/hsufh/COURSES/FALL2022/linux_project_1.html)
> 